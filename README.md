1 АРХИТЕКТУРА ПРОГРАММНОГО СРЕДСТВА В НОТАЦИИ С4

На рисунке 1 представлен контейнерный уровень архитектуры программного средства.

<img width="930" height="575" alt="image" src="https://github.com/user-attachments/assets/16769db3-7de3-46ae-a38e-efa1664a7766" />

Рисунок 1 – Контейнерный уровень архитектуры программного средства 

Программное средство «Кредитный конвейер» предназначено для обработки и принятия решений по кредитным заявкам физических лиц. Основным элементом системы является веб-приложение, разработанное на Angular и TypeScript. Оно предоставляет удобный интерфейс для клиентов, кредитных менеджеров, специалистов по рискам и администраторов. Клиенты могут подать заявку и отслеживать её статус, менеджеры обрабатывают данные и принимают решения, а администраторы следят за стабильной и безопасной работой системы.
Все запросы от веб-приложения обрабатываются серверным API-приложением, реализованным на Java с использованием Spring MVC. Этот компонент выполняет основную бизнес-логику: регистрацию и обработку заявок, взаимодействие с внешними банковскими сервисами и управление процессом принятия решений. Для связи с другими частями системы сервер использует REST API, а также обращается к базе данных и сервису уведомлений.
Хранилищем данных является база PostgreSQL, где сохраняется информация о клиентах, заявках, результатах проверок и итоговых решениях. Она обеспечивает надёжное хранение и быстрый доступ к информации, необходимой для работы системы.
Отдельный сервис уведомлений, построенный на WebSocket, отвечает за информирование клиентов и сотрудников о ходе обработки заявок и результатах решений на электронную почту. Это позволяет пользователям получать актуальные данные в реальном времени.
Важным элементом архитектуры является интеграция с внешней банковской системой. Через REST API серверное приложение получает данные о кредитной истории и финансовом состоянии клиентов. Эти сведения используются при скоринговой проверке и помогают принимать более точные и обоснованные решения.
На рисунке 2 представлен компонентный уровень архитектуры программного средства.

<img width="974" height="644" alt="image" src="https://github.com/user-attachments/assets/05942f05-0d98-4dac-880a-c86536cf37ea" />

Рисунок 2 – Компонентный уровень архитектуры программного средства 

Компонентный уровень архитектуры кредитного конвейера представляет собой совокупность функциональных блоков, каждый из которых реализует определённые задачи и взаимодействует с другими через четко определённые интерфейсы.
Контейнер с API-приложением разбит на несколько контроллеров – компонентов, каждый из которых отвечает за специализированную функцию внутри системы. Веб-клиент, построенный с использованием Angular и TypeScript, общается с бекендом через REST API, обращаясь к соответствующим контроллерам.
User Controller управляет пользовательскими данными, включая регистрацию, обновление профиля и ролевой доступ. Он взаимодействует с базой данных, обеспечивая надежное хранение информации о клиентах и сотрудниках.
Security Controller, основанный на Spring Security, реализует механизмы аутентификации и авторизации, гарантируя, что к функционалу системы имеют доступ только уполномоченные пользователи с разными ролями – от клиентов до администраторов.
Decision Controller содержит логику принятия решений, включая расчеты рисков, используя данные заявок и внешних систем.
Document Controller занимается загрузкой, хранением и проверкой документов, необходимых для рассмотрения кредитных заявок, связывая клиентов, менеджеров и базу данных.
Application Controller служит центром обработки заявок – принимает новые заявки, обновляет их статусы, связывает с решениями и результатами проверок, обеспечивая сквозной бизнес-процесс.
Notification Component Controller формирует и отправляет уведомления пользователям, используя WebSocket для своевременного информирования клиентов и сотрудников о ходе обработки и результатах на электронную почту.
Banking Systems Facade – объединённый интерфейс для интеграции с внешними банковскими системами, системами документооборота и платёжными сервисами, обеспечивая прозрачное и унифицированное взаимодействие.
Вся ключевая информация – данные пользователей, заявки, документы, решения и уведомления – надёжно хранится в базе данных PostgreSQL, обеспечивая высокую производительность, целостность и доступность данных.
Кодовый уровень архитектуры программного средства представлен на рисунке 3.

<img width="974" height="757" alt="image" src="https://github.com/user-attachments/assets/512b6851-848a-42b8-a9fb-04366cd7ddcc" />

Рисунок 3 – Кодовый уровень архитектуры программного средства 

Кодовый уровень архитектуры программного средства «Кредитный конвейер» отражает структуру классов, реализующих бизнес-логику обработки кредитных заявок. В центре модели находится класс Application, который содержит ключевые атрибуты кредитной заявки: идентификатор, данные клиента, сумму кредита, срок и текущий статус. Класс предоставляет метод для обновления статуса, что позволяет отслеживать весь жизненный цикл заявки.
С классом Application связаны другие важные сущности. Класс Document хранит информацию о документах, прикреплённых к заявке: название, путь к файлу и тип документа. Он реализует методы генерации и отправки документов. Класс Decision описывает принятое решение по заявке, включая срок, сумму и результат одобрения. Он связан с конкретной заявкой и фиксирует итог обработки.
Класс User управляет данными пользователей системы: идентификатором, логином, паролем и ролью (клиент, менеджер, администратор). С ним связан класс Notification, который отвечает за хранение и отправку уведомлений. Уведомления содержат текст сообщения, дату отправки и привязаны к конкретному пользователю.
За безопасность отвечает класс Security, который хранит список пользователей и ролей, а также реализует методы аутентификации и авторизации. Он обеспечивает доступ к функциям системы только для проверенных ролей.
Отдельный компонент BankingSystemFacade – служит интерфейсом для взаимодействия с внешними банковскими системами. Он содержит параметры подключения и методы для отправки запросов и получения прогнозов кредитоспособности клиента. Этот фасад скрывает сложность интеграции и предоставляет единый способ работы с внешними сервисами.
Кодовый уровень архитектуры «Кредитного конвейера» демонстрирует чёткое разделение ответственности между классами: Application управляет заявками, Document и Decision обеспечивают документооборот и фиксацию решений, User и Notification отвечают за взаимодействие с пользователями, Security гарантирует защиту доступа, а BankingSystemFacade обеспечивает интеграцию с банковской инфраструктурой.

UML-Диаграммы

<img width="974" height="489" alt="диаграмма развертывания" src="https://github.com/user-attachments/assets/f31f2a55-e618-41b6-93cc-739f8934f748" />
<img width="4386" height="4542" alt="диаграмма классов" src="https://github.com/user-attachments/assets/5c245626-38c0-4b0a-9b8f-e12f85c42ca6" />
<img width="1214" height="1974" alt="диаграмма деятельности" src="https://github.com/user-attachments/assets/89c67fcb-69d6-44a8-9e3f-462ba8f6778a" />
<img width="636" height="941" alt="диаграмма состояний" src="https://github.com/user-attachments/assets/308f916a-5199-456f-9e78-74a24ddf2c6c" />
<img width="1206" height="958" alt="вариантов использования2" src="https://github.com/user-attachments/assets/ea32cdeb-1524-48a8-aa21-0e8197b7b6ab" />


2 СИСТЕМА ДИЗАЙНА ПОЛЬЗОВАТЕЛЬСКОГО ИНТЕРФЕЙСА

В программном средстве разработана система дизайна пользовательского интерфейса. Она включает набор стандартных элементов и правил оформления, которые используются во всех модулях приложения. На рисунке 4 представлен UI Kit программного средства.

<img width="974" height="675" alt="image" src="https://github.com/user-attachments/assets/cb7646d9-1a39-41f4-8614-0e3e6eb8093d" />

Рисунок 4 – UI Kit программного средства 

В систему входят основные компоненты: кнопки, переключатели, чекбоксы, радиокнопки, поля для ввода текста и выпадающие списки. Для выбора дат используется календарь, а для подсказок всплывающие окна с пояснениями. Также предусмотрены иконки для быстрых действий и цветовые обозначения для разных статусов. Определены единые правила для текста – используются одинаковые шрифты и размеры, чтобы информация выглядела аккуратно и легко читалась.
Дополнительно предусмотрены анимации загрузки, которые показывают, что система обрабатывает запрос. 
Основой цветовой гаммы станут оттенки синего и серого, которые создают ощущение надёжности и стабильности. Для акцентных элементов, таких как кнопок действий и ключевых уведомлений – будут использоваться более яркие цвета: зелёный для успешных операций и красный для ошибок.

3 АРХИТЕКТУРА

<img width="974" height="1103" alt="image" src="https://github.com/user-attachments/assets/da7ee30f-7927-4e6a-8e64-b61291c3af84" />

ПОЛЬЗОВАТЕЛЬСКИЙ ИНТЕРФЕЙС
<img width="1920" height="901" alt="кредитный менеджер - главная" src="https://github.com/user-attachments/assets/9aa2f8f0-4356-4fe6-8dcb-d43e19b913d4" />
<img width="1920" height="917" alt="кредитный менеджер - документ" src="https://github.com/user-attachments/assets/fc66540f-fb0c-4019-888e-aade3d0c3cc6" />
<img width="1920" height="912" alt="кредитный менеджер - прикрепление документа" src="https://github.com/user-attachments/assets/dc1fc067-b0f9-43fe-9779-9be4729ee739" />
<img width="1920" height="912" alt="кредитный менеджер - полная анкета" src="https://github.com/user-attachments/assets/85c13fc6-7a17-46d2-81bf-41f7d84491ea" />
<img width="1920" height="902" alt="кредитный менеджер - скоринг принятия решения" src="https://github.com/user-attachments/assets/9da73c9d-1c32-4a7c-a3ee-d772e9e429a9" />
<img width="1920" height="912" alt="риск-менеджер этап принятия решения" src="https://github.com/user-attachments/assets/1d22da7f-3435-4f67-b8ed-f86a353cc88c" />
<img width="1920" height="907" alt="админ - кредитные программы" src="https://github.com/user-attachments/assets/79834374-0d82-47cc-b2d1-9173083def24" />
<img width="1920" height="396" alt="админ - отчетность" src="https://github.com/user-attachments/assets/3c14dfd9-18fe-439b-af33-fbb1f9922f9d" />

БЕЗОПАСНОСТЬ:
Authorization Server – это центральный компонент системы OAuth2, отвечающий за выдачу, хранение и проверку токенов доступа. Он взаимодействует с базой данных, в которой хранится информация о клиентах и пользователях системы.
Используемая конфигурация позволяет гибко управлять политикой доступа и поддерживает разные типы клиентов — от браузерного интерфейса до серверных приложений. Это особенно важно для системы «Кредитный конвейер», в которой предусмотрены как внутренние пользовательские роли (менеджеры, администраторы), так и интеграции с внешними сервисами.
Пример конфигурации Authorization Server представлен ниже:

@Configuration
@EnableAuthorizationServer
public class OAuth2Config implements AuthorizationServerConfigurer {

    @Autowired
    private DataSource dataSource;

    @Override
    public void configure(AuthorizationServerSecurityConfigurer oauthServer) throws Exception {
        oauthServer
                .tokenKeyAccess("permitAll()")  // Разрешаем доступ к endpoint получения токена
                .checkTokenAccess("isAuthenticated()");  // Проверка токена требует аутентификации
    }

    @Override
    public void configure(ClientDetailsServiceConfigurer clients) throws Exception {
        clients.jdbc(dataSource)
                .withClient("browser")
                .secret("{noop}secret")
                .authorizedGrantTypes("password", "refresh_token")
                .scopes("api")
                .and()
                .withClient("application-service")
                .secret("{noop}secret")
                .authorizedGrantTypes("client_credentials")
                .scopes("server");
    }

    @Bean
    public JdbcTokenStore tokenStore() {
        return new CustomJdbcTokenStore(dataSource);
    }
}
Для повышения надежности работы с токенами была создана кастомная реализация JdbcTokenStore, которая обрабатывает исключительные ситуации, возникающие при повреждении токенов (например, из-за сбоев при сериализации или устаревших записей в БД).

@Slf4j
public class CustomJdbcTokenStore extends JdbcTokenStore {

    public CustomJdbcTokenStore(DataSource dataSource) {
        super(dataSource);
    }

    @Override
    public OAuth2AccessToken readAccessToken(String tokenValue) {
        OAuth2AccessToken accessToken = null;

        try {
            accessToken = new DefaultOAuth2AccessToken(tokenValue);
        }
        catch (EmptyResultDataAccessException e) {
            log.info("Failed to find access token for token {}", tokenValue);
        }
        catch (IllegalArgumentException e) {
            log.warn("Failed to deserialize access token for {}", tokenValue, e);
            removeAccessToken(tokenValue);
        }
        return accessToken;
    }
}
Одним из ключевых компонентов системы безопасности в «Кредитном конвейере» является сервис аудита (AuditLogService).
Он регистрирует все критические действия пользователей и системных компонентов: создание, изменение и удаление сущностей, входы в систему, попытки доступа без достаточных прав и другие важные события.

@Service
public class AuditLogService {

    public void create(AuditEventTypeEnum eventType, String entityType, 
                      String entityId, String description, Object details) {
        AuditLog auditLog = new AuditLog();
        auditLog.setEventType(eventType);
        auditLog.setEntityType(entityType);
        auditLog.setEntityId(entityId);
        auditLog.setDescription(description);
        auditLog.setDetails(serializeDetails(details));
        auditLog.setTimestamp(LocalDateTime.now());
        auditLog.setUsername(SecurityUtils.getCurrentUsername());
        
        auditLogRepository.save(auditLog);
    }
}
Для безопасного взаимодействия между фронтендом и бэкендом настроен Cross-Origin Resource Sharing (CORS).
Это предотвращает несанкционированный доступ к API из сторонних доменов и позволяет гибко определять доверенные источники запросов.

@Configuration
public class WebCorsConfig implements WebMvcConfigurer {

    @Override
    public void addCorsMappings(CorsRegistry registry) {
        registry.addMapping("/api/**")
                .allowedOrigins("https://frontend.example.com")
                .allowedMethods("GET", "POST", "PUT", "DELETE", "OPTIONS")
                .allowCredentials(true)
                .maxAge(3600);
    }
}

Дополнительно в конфигурации Spring Security включены следующие механизмы:
	HTTP Strict Transport Security (HSTS) — принудительное использование HTTPS;
	Content Security Policy (CSP) — предотвращение XSS-атак;
	Rate Limiting — ограничение частоты запросов для защиты от brute-force атак на токены и логины;
	Security Headers — настройка заголовков X-Content-Type-Options, X-Frame-Options, Referrer-Policy.


ДОКУМЕНТАЦИЯ:

1.1 Общие сведения

Программное средство «Кредитный конвейер» предоставляет REST API для работы с кредитными заявками физических лиц, пользователями системы, документами и оценками рисков. API реализован на серверной части с использованием Java Spring Boot. Все запросы и ответы передаются в формате JSON. Аутентификация и авторизация пользователей обеспечивается через Spring Security.
Роли пользователей:
  Administrator – управление справочниками, пользователями, отчетами;
  CreditManager – создание и сопровождение кредитных заявок;
  DecisionManager – проверка документов, оценка рисков, принятие решений.

1.2 Основные разделы API:

1 Аутентификация.
POST /auth/login: Авторизация пользователя в системе.
Request body:

{
  "login": "string",
  "password": "string"
}

Response body:

{
  "userId": 1,
  "fullName": "Иван Иванов",
  "role": "CreditManager",
  "token": "jwt-token-string"
}

POST /auth/logout – выход пользователя из системы.

2 Пользователи и роли.
GET /users – получить список всех пользователей (только для Administrator).
POST /users – создать нового пользователя.
GET /users/{userId} – получить информацию о конкретном пользователе.
PUT /users/{userId} – обновить данные пользователя.
DELETE /users/{userId} – удалить пользователя.
Пример структуры пользователя (users):

{
  "userId": 1,
  "login": "ivan123",
  "fullName": "Иван Иванов",
  "email": "ivan@example.com",
  "phone": "+375291234567",
  "role": "CreditManager",
  "status": "active",
  "createdAt": "2025-09-01T10:00:00"
}

GET /roles – получить список всех ролей.

3 Клиенты
GET /clients – список клиентов.
POST /clients – добавить нового клиента.
GET /clients/{clientId} – получить информацию о клиенте.
PUT /clients/{clientId} – обновить данные клиента.
Пример структуры клиента (clients):

{
  "clientId": 1,
  "fullName": "Петр Петров",
  "passportNumber": "AB1234567",
  "taxId": "123456789",
  "phone": "+375291112233",
  "email": "petr@example.com",
  "address": "г. Минск, ул. Ленина, 10",
  "dateOfBirth": "1990-05-12",
  "createdAt": "2025-09-01T12:00:00"
}

4 Кредитные программы
GET /credit-programs – список доступных кредитных программ.
POST /credit-programs – создать новую кредитную программу.
GET /credit-programs/{programId} – информация о программе.
PUT /credit-programs/{programId} – обновить программу.
Пример структуры программы (credit_programs):

{
  "programId": 1,
  "name": "Потребительский кредит",
  "interestRate": 12.5,
  "termMonths": 24,
  "maxAmount": 10000.00,
  "conditions": "Требуется паспорт и справка о доходах",
  "description": "Кредит для физических лиц"
}

5 Заявки на кредит  
GET /applications – список заявок (с фильтрацией по менеджеру, статусу, клиенту).
POST /applications – создание новой заявки.
GET /applications/{applicationId} – информация по заявке.
PUT /applications/{applicationId} – обновление заявки.
DELETE /applications/{applicationId} – удаление заявки (только Administrator).
Пример структуры заявки (applications):

{
  "applicationId": 1,
  "clientId": 1,
  "programId": 1,
  "managerId": 2,
  "amount": 5000.00,
  "requestedAmount": 5000.00,
  "approvedAmount": null,
  "status": "Draft",
  "decisionDate": null,
  "comments": "Нет",
  "createdAt": "2025-09-01T12:30:00",
  "updatedAt": "2025-09-01T12:30:00"
}

6 Документы
GET /applications/{applicationId}/documents – список документов заявки.
POST /applications/{applicationId}/documents – загрузка нового документа.
GET /documents/{documentId} – получить документ.
DELETE /documents/{documentId} – удалить документ.
Пример структуры документа (documents):


{
  "documentId": 1,
  "applicationId": 1,
  "fileName": "passport.pdf",
  "filePath": "/uploads/passport.pdf",
  "documentType": "passport",
  "uploadDate": "2025-09-01T12:35:00"
}

7 Черный список
GET /blacklist – список клиентов в черном списке.
POST /blacklist – добавить клиента в черный список.
DELETE /blacklist/{blacklistId} – удалить запись.
Пример структуры (blacklist):

{
  "blacklistId": 1,
  "clientId": 3,
  "reason": "Просрочка платежей",
  "addedBy": 1,
  "dateAdded": "2025-09-01T13:00:00"
}

8 Оценка рисков
GET /applications/{applicationId}/risk-assessments – список оценок по заявке.
POST /applications/{applicationId}/risk-assessments – провести оценку риска.
PUT /risk-assessments/{riskId} – обновить оценку.
Пример структуры (risk_assessments):

{
  "riskId": 1,
  "applicationId": 1,
  "riskManagerId": 4,
  "score": 85.5,
  "decision": "approve",
  "comments": "Клиент надежный",
  "assessmentDate": "2025-09-01T14:00:00"
}

9 Отчёты
GET /reports – список отчетов.
POST /reports – создание нового отчета.
GET /reports/{reportId} – скачать отчет.
Пример структуры отчета (reports):

{
  "reportId": 1,
  "userId": 1,
  "periodStart": "2025-09-01",
  "periodEnd": "2025-09-30",
  "filePath": "/reports/september.xlsx",
  "createdAt": "2025-10-01T10:00:00"
}

10 Интеграция с внешними системами
Через компонент BankingSystemFacade реализована интеграция с внешними банковскими сервисами для:
  проверки кредитной истории клиента,
  проверки паспортных и налоговых данных,
  получения прогнозов кредитоспособности.
Все запросы происходят через REST API и защищены токенами доступа.

[Спецификация API (swagger.yaml)](swagger.yaml)

ОЦЕНКА КАЧЕСТВА:

Для оценки качества кода программного средства «Кредитный конвейер» были использованы следующие метрики и инструменты:
1 Покрытие кода тестами (Code Coverage)
– общий процент покрытия: 82%  
– покрытие классов: 80%  
– покрытие методов: 85%  
Покрытие кода оценивалось с помощью инструмента JaCoCo. Результаты показывают, что большинство ключевых компонентов системы протестировано, что обеспечивает надежность работы серверной части API.
2 Сложность кода (Cyclomatic Complexity)
– средняя сложность метода: 3.2  
– максимальная сложность метода: 8  
– количество методов с высокой сложностью (>10): 0  
Для анализа использовался инструмент SonarQube. Средняя сложность методов находится в пределах допустимых значений, что упрощает сопровождение и расширение системы.
3 Статический анализ кода
– количество предупреждений: 12 (незначительные, связанные с форматированием и неймингом)  
– дублирование кода: 3%  
– нарушения правил кодирования: отсутствуют критические  
Статический анализ проводился с помощью инструментов PMD, Checkstyle и SonarQube. Анализ показал, что код соответствует принятым стандартам Java и Spring Boot, минимизировано дублирование, и отсутствуют критические ошибки.
4 Тестирование (Unit и интеграционные тесты)
– Unit-тесты: 24  
– интеграционные тесты: 4  
– процент успешных тестов: 100%  
Тестирование выполнено с использованием JUnit 5. Unit-тесты проверяют корректность работы основных сервисов и компонентов, а интеграционные тесты подтверждают взаимодействие компонентов системы и корректность работы API.
В целом, проведенная оценка качества кода показывает, что программное средство соответствует современным требованиям надежности и сопровождаемости.


ТЕСТИРОВАНИЕ:
2 ПРИМЕРЫ UNIT-ТЕСТОВ

Unit-тестирование направлено на проверку корректности работы отдельных функций и модулей системы, изолированных от остальной системы.
Примеры функций, проверяемых unit-тестами
1  Расчет ежемесячного платежа (аннуитетный метод).
2  Валидация входных данных кредитной заявки.
3  Проверка лимитов и условий кредитования.
4  Расчет максимальной суммы кредита на основе кредитного рейтинга клиента.
Unit-тест 1. Расчет ежемесячного платежа:

import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

class PaymentCalculatorTest {

    double calculateMonthlyPayment(double amount, double rate, int term) {
        double monthlyRate = rate / 12 / 100;
        return (amount * monthlyRate) / (1 - Math.pow(1 + monthlyRate, -term));
    }

    @Test
    void testCalculateMonthlyPayment() {
        double result = calculateMonthlyPayment(10000, 12, 12);
        assertEquals(888.49, result, 0.5);
    }
}

Unit-тест 2. Тест валидации кредитной заявки:

import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

class ApplicationValidatorTest {

    boolean validateApplication(CreditApplication app) {
        return app.amount > 0 && app.term > 0 && app.userId != null;
    }

    static class CreditApplication {
        Integer userId;
        double amount;
        int term;

        CreditApplication(Integer userId, double amount, int term) {
            this.userId = userId;
            this.amount = amount;
            this.term = term;
        }
    }

    @Test
    void testValidApplication() {
        CreditApplication app = new CreditApplication(123, 5000, 6);
        assertTrue(validateApplication(app));
    }

    @Test
    void testInvalidApplication() {
        CreditApplication app = new CreditApplication(null, 5000, 6);
        assertFalse(validateApplication(app));
    }
}
Unit-тест 3. Тест проверки кредитных лимитов
Например: если сумма превышает 50 000 — заявка отклоняется.

import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

class CreditLimitTest {

    boolean checkLimit(double amount) {
        return amount <= 50000;  // лимит банка
    }

    @Test
    void testAmountWithinLimit() {
        assertTrue(checkLimit(30000));
    }

    @Test
    void testAmountExceedsLimit() {
        assertFalse(checkLimit(75000));
    }
}

Unit-тест 4. Тест расчёта максимальной суммы кредита по рейтингу
Например:
рейтинг < 600 → максимум 0
рейтинг 600–700 → максимум 10 000
рейтинг > 700 → максимум 30 000

import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

class MaxCreditAmountTest {

    double getMaxCreditAmount(int rating) {
        if (rating < 600) return 0;
        if (rating < 700) return 10000;
        return 30000;
    }

    @Test
    void testLowRating() {
        assertEquals(0, getMaxCreditAmount(550));
    }

    @Test
    void testMediumRating() {
        assertEquals(10000, getMaxCreditAmount(650));
    }

    @Test
    void testHighRating() {
        assertEquals(30000, getMaxCreditAmount(750));
    }
}
Unit-тестирование в разработке программного средства «Кредитный конвейер» применялось для проверки корректности работы отдельных функций и модулей, не зависящих от внешних сервисов и других компонентов системы. Цель unit-тестов состояла в том, чтобы убедиться, что каждая функция бизнес-логики работает строго в соответствии с заданными правилами, корректно обрабатывает входные данные и возвращает предсказуемые результаты.
Для unit-тестирования были выделены ключевые функции кредитного конвейера:
1  Расчёт ежемесячного платежа – тест позволяет определить корректность реализации аннуитетной формулы и проверить, что при разных входных параметрах (сумма, ставка, срок) результат совпадает с расчётным значением.
2  Валидация входных данных кредитной заявки – тестируется, что система корректно отбрасывает заявки без обязательных параметров (ID пользователя, сумма, срок) и принимает корректно оформленные заявки.
3  Проверка лимитов кредитования – тест проверяет, что система верно определяет, превышает ли требуемая сумма установленный для банка лимит, и корректно реагирует на граничные значения.
4  Расчёт максимальной доступной суммы по кредитному рейтингу – тестирование подтверждает, что система использует правильные диапазоны кредитных рейтингов и корректно определяет доступный клиенту максимум.
Unit-тесты выполнялись в полностью изолированной среде без обращений к базе данных или сетевым сервисам. Это позволило локализовать ошибки в отдельных функциях и обеспечить высокую надёжность базовой бизнес-логики кредитного конвейера.

3 ИНТЕГРАЦИОННОЕ ТЕСТИРОВАНИЕ

Интеграционные тесты проверяют корректность взаимодействия модулей и процессов в рамках всей системы.
Основные сценарии интеграционных тестов
1  Полный процесс обработки заявки: от ввода данных до принятия решения и уведомления клиента.
2  Обработка заявок с низким кредитным рейтингом (отклонение).
3  Обработка заявок с превышением лимита кредита (отклонение).
4  Проверка правильности уведомлений клиентов при изменении статуса заявки.
В тестах используется фиктивный сервис TestCreditServices, который имитирует работу зависимостей.
Примеры интеграционных тестов:
Интеграционный тест 1. Полный процесс обработки заявки (успешный сценарий)

import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

public class CreditPipelineIntegrationTest {

    @Test
    public void testFullCreditApplicationFlow() {
        // Arrange
        CreditApplication application =
                new CreditApplication(123, 10000, 12);

        TestCreditServices services = new TestCreditServices();

        CreditPipeline pipeline = new CreditPipeline(
                services, services, services, services
        );

        // Act
        CreditResult result = pipeline.process(application);

        // Assert
        assertEquals("approved", result.getStatus());
        assertTrue(result.isNotificationSent());
    }
}

Интеграционный тест 2. Отклонение заявки из-за низкого кредитного рейтинга:

import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

public class CreditPipelineLimitTest {

    @Test
    public void testApplicationRejectedLimitExceeded() {
        // Arrange
        CreditApplication application =
                new CreditApplication(789, 1000000, 24); // Очень большая сумма

        TestCreditServices services = new TestCreditServices();
        services.setMaxAllowedAmount(50000); // Устанавливаем лимит

        CreditPipeline pipeline = new CreditPipeline(
                services, services, services, services
        );

        // Act
        CreditResult result = pipeline.process(application);

        // Assert
        assertEquals("rejected_limit", result.getStatus());
        assertFalse(result.isNotificationSent());
    }
}
Интеграционное тестирование предназначено для проверки корректности взаимодействия отдельных модулей и компонентов программного средства. В отличие от unit-тестов, интеграционные тесты выполнялись в условиях, максимально приближённых к реальной работе кредитного конвейера, с имитацией работы основных подсистем.
Интеграционное тестирование охватывало следующие ключевые сценарии:
1  Полный процесс обработки кредитной заявки – от валидации и получения кредитного рейтинга до расчёта ежемесячного платежа, сохранения заявки и отправки уведомления клиенту. Тест подтверждает, что все этапы процесса выполняются последовательно и без ошибок.
2  Обработка заявок с низким кредитным рейтингом – проверяется корректность отказа в выдаче кредита и отсутствие шагов, которые должны выполняться только при одобрении (например, отправка уведомления).
Интеграционные тесты обеспечивали проверку совместной работы функций расчётов, модулей валидации, подсистемы рейтинга, подсистемы уведомлений и хранилища данных. Это позволило выявить ошибки взаимодействия, которые не могли быть обнаружены на уровне unit-тестов.




РАЗВЕРТЫВАНИЕ:
1	Подготовка окружения
Шаг 1. Для работы бэкенд-части требуется установленная платформа Java.
Для установки необходимо выполнить следующие действия:
– скачать дистрибутив JDK версии 17 с официального сайта Oracle или OpenJDK;
– запустить установщик и следовать инструкциям мастера;
– после завершения установки открыть командную строку и убедиться, что JDK установлен корректно, выполнив команду:

java -version

Шаг 2. Установка Apache Maven
Maven требуется для сборки бэкенда.
Для установки необходимо:
– скачать архив Apache Maven (версии 3.8 или выше);
– распаковать архив в каталог, например C:\Program Files\Maven;
– добавить путь к Maven в переменную PATH;
– убедиться в корректной установке командой:

mvn -v

Шаг 3. Установка PostgreSQL
Сервер PostgreSQL используется для хранения данных кредитных заявок.
Для установки необходимо:
– скачать дистрибутив PostgreSQL версии 14 или выше;
– выполнить установку, указав пароль для пользователя postgres;
– установить pgAdmin (опционально, для удобства работы с БД).
После установки необходимо перезагрузить систему.
2 Развертывание и настройка базы данных PostgreSQL
Для создания базы необходимо:
Шаг 1. Открыть терминал (psql) командой:

psql -U postgres

Шаг 2. Создать базу данных:

CREATE DATABASE credit_db OWNER credit_user;

Шаг 3. Выйти из psql командой:

\q

3 Подготовка бэкенд-проекта
Шаг 1. Открытие проекта:
Для работы с серверной частью необходимо:
– открыть директорию backend программного средства в среде разработки IntelliJ IDEA или другое IDE;
– дождаться, пока Maven автоматически загрузит зависимости.
Шаг 2. Настройка конфигурационного файла
В каталоге src/main/resources открыть файл application.properties и указать параметры подключения к базе данных:

spring.datasource.url=jdbc:postgresql://localhost:5432/credit_db
spring.datasource.username=credit_user
spring.datasource.password=credit_pass

spring.jpa.hibernate.ddl-auto=update
spring.jpa.show-sql=true
server.port=8080

Шаг 3. Сборка серверной части
Для сборки необходимо:
– открыть терминал (встроенный терминал IDEA или внешний);
– выполнить команду:

mvn clean install

После успешной сборки будет сформирован JAR-файл в каталоге target.
4 Запуск бэкенд-части
Для запуска сервера необходимо открыть проект в IntelliJ IDEA и выполнить запуск серверной части через встроенные средства среды разработки (кнопка Run/Play).
После запуска сервер становится доступен по адресу: http://localhost:8080
5 Подготовка фронтенд-окружения
Шаг 1. Для работы фронтенда (Angular 14) требуется Node.js версии 16-18.
Чтобы установить Node.js, необходимо:
– скачать дистрибутив Node.js версии 16 с официального сайта;
– выполнить установку, следуя шагам мастера;
– после завершения установить пакетный менеджер npm (устанавливается автоматически);
– проверить версии командой:

node -v
npm -v

Шаг 2. Установка Angular CLI
Необходимо выполнить команду:

npm install -g @angular/cli@14

После установки убедиться в корректности:

ng version

6 Подготовка фронтенд-проекта
Шаг 1. Открытие проекта
Чтобы подготовить фронтенд, необходимо:
– открыть папку frontend программного средства в WebStorm или VS Code;
– в нижней части интерфейса открыть вкладку Terminal.
Шаг 2. Настройка конфигурации API
В папке src/environments открыть файл environment.ts и указать адрес бэкенд-сервера:

export const environment = {
  production: false,
  apiUrl: 'http://localhost:8080'
};

Шаг 3. Установка необходимых пакетов
В терминале выполнить последовательные команду:

npm install

Эта команда загрузит все зависимости, необходимые для работы веб-клиента.
7 Запуск фронтенд-части
Для запуска приложения необходимо выполнить команду:

ng serve --open

После успешного запуска фронтенд будет доступен по адресу: http://localhost:4200.
Страница откроется автоматически в браузере.
Если запуск успешен, веб-клиент сможет взаимодействовать с сервером, отправляя запросы на http://localhost:8080.
8 Проверка работоспособности программного средства
После установки всех компонентов необходимо убедиться, что:
1	PostgreSQL запущен.
2	Бэкенд-приложение работает и доступно по адресу:
http://localhost:8080
3	Фронтенд-клиент доступен по адресу:
http://localhost:4200
4	Создание кредитной заявки, просмотр статуса и другие функции работают корректно.
9 Завершение развертывания
После выполнения всех перечисленных действий программное средство «Кредитный конвейер» установлено, настроено и готово к использованию.
